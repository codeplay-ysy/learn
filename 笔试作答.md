## 	秋招笔试作答

严思远		软件2202

#### 1.你认识的联创是怎么样的？你为什么希望加⼊联创？
在我的认识里联创是一个非常优秀的组织。
我很喜欢联创的成员之间的氛围，大家一起水群一起当复读机，这让我看到了联创的和谐融洽的一面。
另外，在之前的学习生活中我从联创的学长们这里得到了不少的帮助。比如说在我最开始决定想要加入联创的时候，学长们为我提供了不少的学习指导，在招新失败后也在鼓励我继续加油。而且因为我们院的很多学长都在联创团队，之前在我们年级的聊天群里面也提出过很多生活等方面的疑问和困惑，还有一些课程上的问题，未来发展的问题，学长们都非常热情的给我们解答。这让我非常感激，我觉得这也肯定是联创团队的一个特点。
而浓厚的学习氛围也是我深切的感受。我的感觉就是，不管大家性格爱好怎么样，联创的成员都给我一种做事认真、善于思考的感觉。就比如说，在夏令营中我学习了拓扑排序，当时的我确实是没有真的深入考虑过，这个东西的作用，在学习的过程中也有很多疑问都是忽略掉了，这很多时候不仅仅是时间是否充裕的问题，我感觉到自己其实缺乏一种深挖深究的态度，但是当时学长的提问让我意识到了这一点。

而我为什么希望加入联创？

我觉得自己有些很明显的问题。比如说我感觉自己很懒散，我是说那种不愿跳出舒适圈的感觉，比如说我不擅长动手，比如说我经历过的挑战太少了。
而联创恰恰能够弥补我的不足。
在参加联创招新的过程中，我一次次地在跳出自己的圈子：我开始自己学会去查阅资料；我开始去看那些曾让我难以读进去的书；我从一个只喜欢抱着课本和视频看着学习的人，希望能够一步登天的人，开始逐渐逼着自己不断去动手，而不是说“等我把这个看完再一起做”...
我曾会对各种困难和挑战感到焦虑，哪怕是在一个月前的夏令营最后找不到组队队友的时候，我都还是那个容易紧张焦虑的人。然而没有挑战就没有进步，我在这个过程中心态有非常大的进步和改变。拿招新来说，招新对我就像是一张火车票，曾经的我就是个不成熟的孩子，患得患失，害怕错过检票时间，一旦真的错过了，就只知道着急和难过，只会想着错过时间点的后果。而现在，招新还是那张火车票，我却不是那个小孩子，加入联创仍然是我坚持的目标，但是万一错过了，我只会想办法弥补，看向前面的路。因为招新这个过程本身对我来说就是一次锻炼，我更想把这当做一次历练的机会，而不再是单纯的考核。毕竟后面的路还长，我只要不断进步就好了。
我也曾担心自己到底能不能和学长们融洽相处，因为我在和不太熟悉的人相处的时候经常过于正经和放不开，但是我又喜欢那种放松的关系和环境，我有时候会担心“别人还要多久才会对我失望”，为此我一直以来都有些诚惶诚恐。但是现在的我也已经放平了心态，毕竟人与人的相识相知是一个长期的过程，这不应该是我担心的问题，我相信在对我有足够的了解后大家都能成为很好的朋友。
以上的内容再说得具体一些，我的后端的学习就是一个例子。我意识到我本身在学习方法上有我的弱势，我不是一个能够在闭门造车的情况下学得很好，然后还能特别轻易地坚持下去的人。从我上次招新到现在，已经有六个月的时间，我能够感觉到我的学习进度和很多人相比很缓慢。再拿夏令营来说，我在夏令营的三个星期学到的东西还要胜过我前三个月的学习内容的总和。前面我也说了，我一直在尝试跳出自己的舒适圈，但是这仍然是我的一个弱项，我觉得我很多时候需要有外界的压力逼自己一把，我才能更好地激发自己的潜能，我才能走得更快更远。
我也很喜欢从不同的优秀的人身上学习各种长处，看到别人做得好的地方我总是能够有所感触，接触不同的人我才能更快的进步。就比如说我跟着同学参加unique Hackday，学到了很多利用资源的方式，认识到了做项目前有一个清晰的计划的重要性，还意识到在自己做事的时候，找到志同道合的队友的重要性。说实话，这个过程中我并没有学到太多技术上的东西，反倒是那些对我来说很有用的经验和感悟就是莫名其妙的出现了。我只知道，这里面的共同点就是向他人学习，而联创肯定能给我提供一个很好的学习他人的环境。
最后从内因上来讲，我加入联创的动力来自于不安分的心，来自于不甘于平凡的心。我还有梦想要实现，我还想要站得更高走得更远。所以，联创这样的能够让我学习和成长的平台，我肯定会全力争取加入的，哪怕这次再被淘汰也是一样。

#### 	2.你对未来的规划是什么样的？
我对未来的规划很坚定但是并不算明确。我始终决心要在未来的日子里自主创业，成就自己的事业。而我自认为学识尚浅，眼界不开阔，我不敢说我要怎么才能成功。所以我的第一目标就是加入联创。我现在就能够知道的加入联创的优点就有很多，比如我会在加入之后更加深入地学习各种技术，比如我能够结识更多在各个领域各个方面有能力的人，比如我能够锻炼自己应对各种任务和工作的能力以及交涉能力等等。加入联创之后我肯定就要主动迈入“快车道”了，我已经做好了心理准备，很多东西我会主动去做主动去学，而且是下大功夫去学，我应该会变得更忙，压力也可能会更大。另外我还有些可能不太成熟的想法，比如说我以后可能不太想读研究生，如果我有非常好的机会的话，我宁愿早点出去闯荡。当然这只是我的片面认知，真正了解具体情况后我才会做出最后的决定。
#### 3.你学习后端多久了？你了解的后端是什么样的？前端和后端有什么关系呢？
我学习后端有六个月了。我了解的后端通常是一个软件应用程序或网站的服务器端，负责处理数据存储、处理业务逻辑、与数据库交互、安全性和性能等方面的任务。随着学习的深入，我逐渐认识到一些数据结构在后端中的作用，同时后端学习中很多时候是要深究计算机的一些较为底层的逻辑和知识的。这些是为了能够在服务器端的开发中实现更好的性能，更高的安全性等等。另外我发现自己在生活中，很多时候就会不自觉思考一些存储啊、性能啊相关的问题，就比如QQ的聊天记录是怎样的一种存储模式，如何实现的不同设备之间聊天记录的共享和隔离等等（当然还没做过深入的研究），我认为这是后端学习给我带来的影响。
我认为后端和前端是一个合作共建的关系。前端负责用户界面和用户体验，后端负责处理数据和业务逻辑，很多时候我们后端做的服务器端要投入使用，肯定是需要有前端的设计的，这是为了满足用户的需求。
#### 4.简单介绍⼀下写过的项⽬，若⽆可留空。
目前我做过的项目有gin、gorm框架的仿写、RPC通信、groupcache的仿写。另外做过聊天论坛的后端设计。
#### 5.对于⼀个int类型的值（32位）⽐如108，⽤⼆进制表⽰为1101100，⽤⼗六进制表⽰为0x6c，请 编写⼀段c程序，打印某int类型的数的⼗六进制表⽰。（⼿动实现，不允许使⽤语⾔内置的⼗六进 制打印功能）
```
#include <stdio.h>

void print_hex(int num) {
    char hex_digits[] = "0123456789ABCDEF";
    char hex[9]; //32位int值对应的是8位十六进制
    hex[8] = '\0'; 

    for (int i = 7; i >= 0; i--) {
        int hex_value = (num >> (4 * i)) & 0xF; 
        hex[i] = hex_digits[hex_value];
    }

    printf("0x%s\n", hex); // 打印带有"0x"前缀的十六进制数
}

int main() {
    print_hex(108);
    return 0;
}
```
#### 6.给出以下c语⾔的代码，分析结构体所占的字节数，并写出在相同字段下占⽤字节数最少的结构体 形式。
该结构体共占用24字节。char 1字节 + 3字节填充 + int 4字节；char 1字节 + 7字节填充；double 8字节。
改为 
```
struct B {
 char a;
 char c;
 int b;
 double d; };
```
只占用16字节。
#### 7.下⾯是⼀段python程序，请修改这段程序让其有预期的输出，并解释这段程序没有达到预期的原因
修改后的程序如下：
```
def func(arg1=None):
    if arg1 is None:
        arg1 = []
    arg1.append('a')
    print(arg1)

func()
func(['a'])
func()

```
没有达到预期的原因是python在函数参数的默认值只在函数定义的时候计算一次，后续的使用中都共享同一个参数。
#### 8.交换两个int类型的数的值在写程序时时常使⽤到，请使⽤c/c++编程，给出三种或以上的交换函数 swap(...)的实现⽅式。
第一种：
```
void swap1(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

```
第二种：
```
void swap2(int *a, int *b) { 
*a = *a + *b; 
*b = *a - *b;
*a = *a - *b; 
}
```
第三种：
```
void swap3(int *a, int *b) {
    *a = *a ^ *b;
    *b = *a ^ *b;
    *a = *a ^ *b;
}
```
#### 9.
#### 10.
HTTP是一种用于在网络上传输超文本（如网页）和其他资源的应用层协议。HTTP协议的主要用于Web浏览器和Web服务器之间的通信，从客户端向服务器请求Web页面或资源，以及从服务器将这些资源传送到客户端。HTTPS是HTTP的安全版本。HTTPS通过使用加密技术保护数据传输的安全性和隐私性。它使用SSL/TLS协议对通信内容进行加密，从而防止数据被拦截或篡改。HTTPS通常用于敏感信息的传输，如登录凭据、信用卡信息和个人数据。
```
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

func main() {
    r := gin.Default()

    r.POST("/send", func(c *gin.Context) {
        // 定义请求参数
        json_data := map[string]interface{}{
            "name":     "unique studio",
            "location": "Wuhan Hubei China",
            "nature":   "Student Association",
            "members": []map[string]interface{}{
                {"name": "zhangsan", "age": 19, "group": "web"},
                {"name": "lisi", "age": 20, "group": "lab"},
                {"name": "wangwu", "age": 21, "group": "ai"},
            },
        }

        form_data := map[string]interface{}{
            "slogan": "welcome to web!",
        }

      

        c.JSON(http.StatusOK, gin.H{
            "json_data": json_data,
            "form_data": form_data,
        })
    })

    r.Run(":8080") 
}

```
#### 11.
Cookie是**存储在客户端浏览器上**的小型文本文件，由服务器发送到客户端，然后在后续的HTTP请求中被客户端发送回服务器。Cookie通常用于存储用户身份验证令牌、会话标识和其他客户端状态信息。
Session是服务器端存储的用户会话数据，**通常存储在服务器内存、数据库或其他存储介质中**。服务器将一个唯一的会话标识（通常是一个Session ID）存储在Cookie中，客户端浏览器将这个Session ID发送回服务器来关联用户和其会话数据。
JWT是一种用于在客户端和服务器之间传递安全信息的轻量级标准。它是一个包含用户声明信息的令牌，通过签名或加密确保令牌的完整性和安全性。JWT包括头部、载荷和签名三个部分。
#### 12.
`route -n` 指令输出如图所示：
![这是从虚拟机上进行的测试](/imgs/2023-09-14/DSOz7YK2zScpok0m.png)
显示内核的路由表，以及相关的网络信息。
`-n`选项表示不要解析主机名，直接显示IP地址，可以提高命令的执行速度。
`netstat -rn`指令输出如图：
![输入图片说明](/imgs/2023-09-14/A5jKRasCoDAuttsK.png)
`- rn`的`r`是显示路由表，`n`是不要解析主机名
#### 13.
三次握手：用于建立TCP连接，三次握手可以确保客户端和服务端均准备就绪
1.  **第一次握手**：客户端向服务器发送一个SYN标志位的TCP数据包，表示请求建立连接。此时客户端进入"SYN-SENT"状态。
    
2.  **第二次握手**：服务器收到客户端的SYN请求后，回复一个带有SYN和ACK标志位的数据包，表示接受连接请求，并为连接分配资源。此时服务器进入"SYN-RECEIVED"状态。
    
3.  **第三次握手**：客户端收到服务器的响应后，发送一个带有ACK标志位的数据包，表示连接建立成功。此时双方都进入"ESTABLISHED"状态，连接建立完成，可以开始传输数据。

四次挥手：用于终止TCP连接，可以确保双方的数据传输已经完毕

1.  **第一次挥手**：当一个端口完成数据传输后，它发送一个带有FIN（结束）标志位的数据包给对方，表示不再发送数据。此时发送方进入"FIN-WAIT-1"状态。
    
6.  **第二次挥手**：接收方收到FIN后，回复一个带有ACK标志位的数据包，表示已经接受到FIN，并且可以继续传输数据。此时接收方进入"CLOSE-WAIT"状态。
    
7.  **第三次挥手**：接收方在完成数据传输后，发送一个带有FIN标志位的数据包给发送方，表示自己也不再发送数据。此时接收方进入"LAST-ACK"状态。
    
8.  **第四次挥手**：发送方收到接收方的FIN后，回复一个带有ACK标志位的数据包，表示接受到FIN，并进入"TIME-WAIT"状态。在一段时间后，发送方自动进入"CLOSED"状态。接收方在收到最后的ACK后，也进入"CLOSED"状态。
报文头部的变化是其flags字段的改变，标志位的改变。
#### 14.
由于服务端的端口可以同时监听多个请求，而客户端理论最大端口数量是65535，所以最多应该可以建立65535个连接。但是如果创建多个虚拟ip，应该可以实现更多的连接？(n+1)*65535个连接
#### 15. 
`SELECT * FROM article;`这个语句可以查询article表中的所有数据。
```
SELECT * FROM article
LIMIT 10
OFFSET 10;
```
`LIMIT 10`表示10条数据一页，`OFFSET 10;`会从第二页开始，也就是11-20条。
#### 16.
数据库事务是一种SQL操作，被视为单个操作单元，要么全部成功执行，要么全部失败回滚，以确保数据的一致性和完整性。通常用于银行账户交易等重要的数据的存储和访问。事务的ACID特性：

1. **原子性（Atomicity）**：
   - 原子性是指事务是不可分割的单元，要么全部执行成功，要么全部失败回滚，没有中间状态。如果在事务执行期间发生错误或故障，系统会自动回滚事务，以确保数据的一致性。原子性确保了事务的完整性。

2. **一致性（Consistency）**：
   - 一致性要求事务在开始和结束时数据库必须保持一致状态。如果一个事务违反了数据库的完整性约束，那么该事务将被回滚，数据库状态将被还原到事务开始前的状态，以确保数据的一致性。

3. **隔离性（Isolation）**：
   - 隔离性指多个事务并发执行时，每个事务的操作都应该与其他事务隔离开来，互不干扰。这意味着一个事务的结果在提交之前对其他事务是不可见的。隔离性可以防止并发执行时的数据竞争和不一致性。

4. **持久性（Durability）**：
   - 持久性要求一旦事务被提交，其结果应该永久保存在数据库中，即使系统发生故障或重启。这确保了数据的持久性和可恢复性。
   
ACID特性可以确保数据库中执行的事务的安全性一致性，即使在并发访问和系统故障的情况下也能维持数据的一致性和完整性。数据库管理系统使用日志来记录事务的操作，以便在故障恢复时能够恢复到一致状态。在多用户环境下，事务的使用可以确保数据库操作的可靠性。
#### 17.
1.  **日志文件（Log Files）**：
    
    -   使用日志文件来记录每个写操作，然后定期将这些写操作批量写入数据库。
2.  **批处理**：   
    -   将多个写操作收集到一个批次中，然后一次性执行这些写操作。可以减少写入的次数，提高写入性能。批处理通常用于需要处理大量写操作的情况，例如日志处理。
3.  **缓存**：
    
    -   使用缓存来存储部分数据，然后定期将缓存中的数据批量写入数据库。可以减少对数据库的直接写入操作，提高写入性能。缓存可以是内存缓存或分布式缓存。
4.  **列式存储**：
    
    -   列式存储数据库将数据按列而不是按行存储，对于某些写多读少的分析型应用非常有效。列式存储可以提供更好的写入性能和查询性能，尤其是在聚合查询场景下。
5.  **NoSQL数据库**：
    
    -   NoSQL数据库通常具有分布式架构和优化的写入性能，适用于大规模写入的场景。
6.  **数据分区**：
    
    -   将数据分区存储在不同的物理设备上，以减少单个设备的写入压力。这可以提高写入性能，并允许水平扩展。

#### 18.
1.  **进程（Process）**：
    
    -   进程是操作系统中的独立执行单元，每个进程都有自己的独立内存空间和系统资源。进程之间不能直接共享内存，通信需要使用进程间通信（IPC）机制，如管道、消息队列、共享内存等。
    -   进程可以同时执行多个任务，但在切换进程时需要较多的上下文切换开销。
2.  **线程（Thread）**：
    
    -   线程是进程内的执行单元，多个线程共享同一进程的内存空间和资源。因此，线程之间可以方便地共享数据，通信相对容易。
    -   线程可以实现多任务并发执行，但线程切换的开销较小，因为线程共享同一进程的地址空间。
3.  **协程（Coroutine）**：
    
    -   协程是一种用态的轻量级线程，由程序员在代码中显式地控制，而不是由操作系统调度。协程可以在同一个线程内实现多个任务的切换，而不需要线程切换的开销。
    -   协程通常比线程更轻量，因为协程不需要操作系统级别的上下文切换。协程通常更适用于高度并发和I/O密集型的任务。
   
 **三者区别：**
 -   进程是操作系统中的独立执行单元，拥有独立的内存空间，通信需要IPC。
-   线程是进程内的执行单元，多个线程共享同一进程的内存空间，通信相对容易，但线程切换开销较小。
-   协程是轻量级的用户态线程，由程序员控制，适用于高并发和I/O密集型任务，避免了线程切换的开销。

#### 19.
```
err := someFunc(func() { 
result := add(2, 3) 
//相关的处理逻辑
})
```
#### 20.
输出为`false`
之所以会输出false，是因为any类型的变量在和nil比较时，会先将其转换为interface{}类型，而interface{}类型的变量在和nil比较时，只有当其动态类型和动态值都为nil时，才会返回true，否则返回false。在上面的代码中，any类型的变量i的动态类型为*int，动态值为nil，i == nil返回false。
#### 21.
这段 程序的问题是两个线程 `thread1` 和 `thread2` 同时对全局变量 `num` 进行写操作，可能会在同一时刻读取相同的`num`，各自递增然后返回；或者也可能会因为线程交错，thread1只递增了40次，而thread2执行了50次，再thread1递增60次，这样结果也会小于200
下面是修改后的代码：
```
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

int num = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; 

void *thread1() {
    for (int i = 0; i < 100; i++) {
        pthread_mutex_lock(&mutex); 
        num++;
        pthread_mutex_unlock(&mutex); 
    }
    return NULL;
}

void *thread2() {
    for (int i = 0; i < 100; i++) {
        pthread_mutex_lock(&mutex); 
        num++;
        pthread_mutex_unlock(&mutex); 
    }
    return NULL;
}

int main() {
    pthread_t tid1, tid2;
    pthread_create(&tid1, NULL, thread1, NULL);
    pthread_create(&tid2, NULL, thread2, NULL);
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
    printf("num = %d\n", num);
    return 0;
}
```

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyMjkwMDg2MTUsMTY2NzA1NzQ1MywxMD
Y4NjA4OTM0LC0xMDM2NDk3Nyw2MjI2NzE4MTEsMTY2NDkxNzAz
NCw0ODk5NTczMzUsLTEyODY0MzM5MiwxMjYyODk1NzM3LDIxNT
M5MjYyNCwxNzU4ODY0NDUyLDE1MjI2OTQ5OTUsLTE0NDkyMjEx
ODIsLTY4MTI3NDM0MSwxMDU5MTIxOTM2LDQ2ODM5NDYxNywtNj
Y4OTMyMzE0LDk5MzgzNDc0NCwtMTk1NzAwOTQxNSw1NTUyMDA4
ODldfQ==
-->